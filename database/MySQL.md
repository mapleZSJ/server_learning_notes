## MySQL索引的底层数据结构

**MySQL 常见索引有 B+Tree 索引、HASH 索引、Full-Text 索引:**    <br/>

**1 B+Tree 索引**：是 MySQL 默认存储引擎 InnoDB 采用索引数据结构，所有数据都存储在叶子节点中，非叶子节点只存储索引，提高范围查询的性能和减少磁盘IO开销，千万级的数据量 b+树的树高只需要 3 层。  <br/>

**2 Full-Text 索引**：全文索引用于对文本内容进行搜索，采用倒排索引等数据结构来实现全文搜索功能，支持关键字搜索和模糊查询。    <br/>

**3 哈希索引**：哈希索引通过哈希函数计算键的存储位置，适用于等值查找，速度快但不支持范围查找。    <br>

<br>

**为什么用B+树：**   <br>

**1 B+Tree vs 二叉树**：对于有 N 个叶子节点的 B+Tree，其搜索复杂度为O(logdN)，其中 d 表示节点允许的最大子节点个数为 d 个;    <br/>
在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3\~4 层左右，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据;    <br/>
而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 O(logN)，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。    <br/>

**2 B+Tree vs Hash**：Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。   <br/>

**3 B+Tree vs B Tree**：B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。    <br/>
另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。    <br/>

<br>

**事务的隔离级别：**  (按隔离水平从低到高排序)   <br/>

**1 读未提交**：指一个事务还没提交时，它做的变更就能被其他事务看到；   <br/>
**2 读提交**：指一个事务提交之后，它做的变更才能被其他事务看到；   <br/>
**3 可重复读**：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别；   <br/>
**4 串行化**：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成才能继续执行；   <br/>

<br>

**当前读和快照读的区别：**    <br/>

**1 当前读**：可以读取其他事务最新已经提交的事务，执行的过程中会通过加行级锁的方式保证事务的隔离性，比如 select for update、update、 delete 都属于当前读。    <br/>

**2 快照读**：无锁，主要是基于mvcc机制实现的，可重复读和读已提交的 select 都属于快照读。    <br/>
「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，保证了在事务期间读到的数据都是事务启动前的记录。    <br/>
「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。    <br/>


