## 进程间通信方式


由于**每个进程**的用户空间都是独立的，不能相互访问，这时就需要借助**内核空间**来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。     <br/>

**1 管道**     <br/>
Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为【匿名管道】和【命名管道】。    <br/>

**匿名管道**：顾名思义，它没有名字标识，匿名管道是特殊文件只存在于 内存，没有存在于文件系统中，shell 命令中的「|」竖线就是匿名管道，  <br/>
通信的数据是 无格式的流 并且 大小受限，通信的方式是 单向的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来匿名管道是只能用于存在 父子关系 的进程间通信，  <br/>
匿名管道的生命周期随着 进程 创建而建立，随着进程终止而消失。    <br>

**命名管道**：突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个 设备文件 进行通信;  <br/>
另外，不管是匿名管道还是命名管道，进程写入的数据都是缓存在 内核 中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循 先进先出原则，不支持 lseek 之类的文件定位操作。     <br/>

**2 消息队列**   <br/>
**消息队列**：
克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在 内核的【消息链表】，消息队列的消息体是可以用户 自定义的数据类型，     <br/>
发送数据时，会被分成一个一个 独立的消息体，当然接收数据时，也要与发送方发送的消息体的 数据类型保持一致，这样才能保证读取的数据是正确的。    <br/>
消息队列通信的 速度不是最及时的，毕竟每次数据的写入和读取都需要经过 用户态与内核态 之间的 拷贝过程。    <br/>

**3 共享内存**   <br/>
**共享内存**：可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，它直接分配一个 共享空间，每个进程都可以直接访问，就像访问进程自己的空间一样快捷方便，     <br/>
不需要陷入内核态或者系统调用，大大提高了通信的速度，享有 最快的进程间通信方式 之名。但是便捷高效的共享内存通信，带来新的问题，多进程 竞争同个共享资源 会造成数据的错乱。    <br/>

**4 信号量**    <br/>
**信号量**：保护 共享资源，以确保任何时刻只能有 一个进程 访问共享资源，这种方式就是 互斥访问。   <br/>
信号量不仅可以实现访问的互斥性，还可以实现 进程间的同步，信号量其实是一个 计数器，表示的是 资源个数，其值可以通过两个原子操作来控制，分别是 P 操作和 V 操作。    <br/>
【进程同步：主要任务是使并发执行的诸进程之间能有效地 共享资源 和 相互合作，使执行的结果具有 可再现性】

**5 信号**   <br/>
**信号**：是 异步通信机制，信号可以在 应用进程和内核 之间 直接交互，内核也可以利用信号来 通知 用户空间的进程发生了哪些 系统事件，    <br/>
信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号。    <br/>
有两个信号是应用进程 无法捕捉和忽略的，即 SIGKILL 和 SIGSTOP，这是为了方便我们能在 任何时候结束或停止某个进程。     <br/>

**6 socket**     <br/>
**socket**：也称套接字，前面说到的通信机制都是工作于同一台主机，Socket可用于 不同的主机进程间通信，还可以用于 本地主机进程间通信，        <br/>
可根据创建 Socket的类型 不同，分为三种常见的 通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。      <br/>


