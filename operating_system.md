## 进程间通信方式
每个进程的 用户地址空间 都是独立的，一般是不能互相访问的，但 内核空间 是每个进程都 共享 的，所以进程之间要通信必须通过内核，借助**内核空间**来实现进程间通信。   <br/>
 

### 1 管道
Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为【匿名管道】和【命名管道】。 管道这种通信方式效率低，不适合进程间频繁地交换数据，但是能很容易得知管道里的数据已被另一个进程读取【执行命令将数据写入管道，只有当管道里的数据被读完后(另一个命令)，命令才可以正常退出】。    <br/>

**匿名管道**：顾名思义，它没有名字标识，匿名管道是特殊文件只存在于 内存，没有存在于文件系统中，shell 命令中的「|」竖线就是匿名管道【 | 的功能是将前一个命令的输出，作为后一个命令的输入】，  <br/>
通信的数据是 无格式的流 并且 大小受限，通信的方式是 单向的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来匿名管道是只能用于存在 父子关系 的进程间通信，  <br/>
匿名管道的生命周期随着 进程 创建而建立，随着进程终止而消失。    <br>

**命名管道(FIFO)**：突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个 设备文件 进行通信;  <br/>
另外，不管是匿名管道还是命名管道，进程写入的数据都是缓存在 内核 中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循 先进先出原则，不支持 lseek 之类的文件定位操作。     <br/>
【在使用命名管道前，先需要通过 mkfifo 命令来创建，并且指定管道名字，如：mkfifo myPipe。myPipe的文件类型是p】     <br/>

### 2 消息队列
**消息队列**：
克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在 内核的【消息链表】，消息队列的消息体是可以用户 自定义的数据类型，     <br/>
发送数据时，会被分成一个一个 独立的消息体，当然接收数据时，也要与发送方发送的消息体的 数据类型保持一致，这样才能保证读取的数据是正确的。    <br/>
消息队列通信的 速度不是最及时的，毕竟每次数据的写入和读取都需要经过 用户态与内核态 之间的 拷贝过程。    <br/>

### 3 共享内存
**共享内存**：可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，它直接分配一个 共享空间，每个进程都可以直接访问，就像访问进程自己的空间一样快捷方便，     <br/>
不需要陷入内核态或者系统调用，大大提高了通信的速度，享有 最快的进程间通信方式 之名。但是便捷高效的共享内存通信，带来新的问题，多进程 竞争同个共享资源 会造成数据的错乱。    <br/>

### 4 信号量
**信号量**：保护 共享资源，以确保任何时刻只能有 一个进程 访问共享资源，这种方式就是 互斥访问。   <br/>
信号量不仅可以实现访问的互斥性，还可以实现 进程间的同步，信号量其实是一个 计数器，表示的是 资源个数，其值可以通过两个原子操作来控制，分别是 P 操作和 V 操作。    <br/>
【进程同步：主要任务是使并发执行的诸进程之间能有效地 共享资源 和 相互合作，使执行的结果具有 可再现性】

### 5 信号
**信号**：是 异步通信机制，信号可以在 应用进程和内核 之间 直接交互，内核也可以利用信号来 通知 用户空间的进程发生了哪些 系统事件，    <br/>
信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号。    <br/>
有两个信号是应用进程 无法捕捉和忽略的，即 SIGKILL 和 SIGSTOP，这是为了方便我们能在 任何时候结束或停止某个进程。     <br/>

### 6 socket
**socket**：也称套接字，前面说到的通信机制都是工作于同一台主机，Socket可用于 跨网络与不同主机的进程间通信，还可以用于 本地主机进程间通信        <br/>

创建 socket 的系统调用：  <br/>
int socket(int domain, int type, int protocal)     <br/>

domain 参数用来指定 协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于 IPV6、AF_LOCAL/AF_UNIX 用于 本机；  <br/>
type 参数用来指定 通信特性，比如 SOCK_STREAM 表示的是字节流 对应 TCP；SOCK_DGRAM  表示的是数据报 对应 UDP；SOCK_RAW 表示的是 原始套接字；   <br/>
protocal 参数原本是用来指定 通信协议，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可；     <br/>


根据创建 Socket的类型 不同，分为三种常见的 通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。      <br/>
实现 TCP 字节流通信：socket 类型是 AF_INET 和 SOCK_STREAM；     <br/>
服务端和客户端初始化 socket，得到 文件描述符；     <br/>
服务端调用 bind，将绑定在 IP 地址和端口;     <br/>
服务端调用 listen，进行 监听；     <br/>
服务端调用 accept，等待 客户端连接；     <br/>
客户端调用 connect，向 服务器端的地址和端口 发起 连接请求【TCP三次握手】；     <br/>
服务端 accept 返回用于传输的 socket 的 文件描述符；     <br/>
客户端调用 write 写入数据；服务端调用 read 读取数据【双方通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样】；     <br/>
客户端 断开连接时，会调用 close，那么服务端 read 读取数据的时候，就会读取到了 EOF，待处理完数据后，服务端调用 close，表示 连接关闭。     <br/>

【ps：服务端调用 accept 时，连接成功了会返回一个 已完成连接的 socket，后续用来 传输数据。所以，监听的socket 和 真正用来传送数据的socket，是「两个」socket，一个叫作 监听socket，一个叫作 已完成连接socket。】   <br/>


实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；      <br/>
UDP 是没有连接的，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。     <br/>
对于 UDP 来说，不需要 维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。   <br/>
另外，每次通信时，调用 sendto 和 recvfrom，都要传入 目标主机的 IP 地址和端口。   <br/>

实现 本地进程间通信：「本地字节流 socket」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；     <br/>




<br>

## 进程和线程的区别

**1 本质区别**：进程是 操作系统资源分配 的基本单位，而线程是 任务调度和执行 的基本单位；      <br/>
**2 开销方面**：每个进程都有 独立的代码和数据空间（程序上下文）【代码、数据、文件】，程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己 独立的运行栈和程序计数器（PC）【寄存器、堆栈】，线程之间切换的开销小；      <br/>
**3 稳定性方面**：进程中某个 线程 如果崩溃了，可能会导致整个进程都崩溃。而进程中的 子进程 崩溃，并不会影响其他进程；      <br/>
**4 内存分配方面**：系统在运行的时候会为每个进程 分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能 共享资源；    <br/>
**5 包含关系**：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。      <br/>


<br>


## 协程为什么比线程快？

协程比线程快的主要原因有以下几点：

**用户态切换**：协程是在用户态下进行切换，不涉及内核态的上下文切换和系统调用，切换成本低，执行效率高。

**轻量级**：协程是由用户自己管理的，不需要操作系统进行调度和管理，占用的资源较少，创建和销毁的开销小。

**高并发**：协程可以在同一个线程内并发执行，避免了线程切换和同步的开销，提高了并发处理能力。


