## TCP

**一台机器理论上能创建多少条TCP连接：**    <br/>
如果在不考虑服务器的内存和文件句柄资源的情况下，理论上一个服务端进程最多能支持约为 2 的 48 次方（2^32 (ip数) * 2^16 (端口数），约等于两百多万亿。    <br/>

但是在实际中是支持不了这个数值的，每个 TCP 连接都是一个文件，会占用文件句柄资源，也会占用一定的内存空间。    <br/>

一台服务器是可以有多个服务端进程的，每个服务端进程监听不同的端口，当然所有65535个端口你都可以用来监听一遍，这样理论上线就到了2的32次方（ip数）×2的16次方（port数）×2的16次方（服务器port数）个，
基本相当于无穷个了。    <br/>

但Linux每维护一条TCP连接都要花费内存资源的，每一条静止状态（不发送数据和不接收数据）的 TCP 连接大约需要 3.44K 的内存，那么 8 GB 物理内存的服务器，
最大能支持的 TCP 连接数=8GB/3.44KB=2,438,956（约240万）。    <br/>

实际过程中的 TCP 连接，还会进行发送数据和接收数据了，那么这些过程还是会额外消耗更多的内存资源的，并发很难达到百万级别。    <br/>

<br/>

**TCP 如何保证传输的可靠性：**    <br/>
1 数据包传输：应用数据被切割成最适合发送的数据包，再传输给网络段，这块涉及半包和粘包，切割和合并 Nagle 算法等问题，还涉及到数据链路层的 MTU 和网络传输层的 MSS 的限制。    <br/>

2 序列号：序列号用于对数据包进行排序和重组，以保证数据的顺序性；利用序列号保证数据包有序，并且按序列号进行排序和数据包去重。    <br/>

3 校验和：TCP 校验和机制 CRC 循环冗余校验。数据在传输过程中如果发生变化，那么校验和就会产生差别，TCP 会丢弃这个报文段，会请求发送方重传数据，并且不会发 ACK 确认。    <br/>

4 确认和重传机制：TCP使用确认和重传机制来确保数据的可靠传输。发送方在发送数据后，会等待接收方发送确认（ACK）信号。如果发送方在合理的时间内未收到确认(如：数据包丢失、或者由于网络延迟没有收到 ACK)，就会认为数据丢失，触发重传机制，重新发送数据。    <br/>

5 流量控制：TCP使用滑动窗口机制进行流量控制，TCP 每一方都有固定大小的缓冲空间，这里面涉及到一个反向压力的概念，根据接收方的处理速率，能够给发送方进行反馈，发送方能够去调整发送的速率，防止包丢失。    <br/>

6 拥塞控制：TCP通过拥塞控制算法来避免网络拥塞，并在发生拥塞时降低数据的发送速率。TCP 发送数据由两个变量控制，接受方接受速率，网络拥塞（延迟）程度，发送方发送的数据的大小是滑动窗口和拥塞窗口的最小值。拥塞控制算法包括慢启动、拥塞避免、快速重传和快速恢复等。   <br/>

<br/>

**TCP半包和粘包问题：**    <br/>
它们是在数据传输过程中可能出现的两种常见问题：  <br/>

半包问题：当发送方将数据拆分成较小的数据包发送，而接收方一次性读取的数据量小于发送方发送的数据包大小时，就会导致接收方接收到的数据不完整，即出现了半包问题。  <br/>

粘包问题：与半包问题相反，粘包问题是指接收方一次性读取的数据量大于发送方发送的数据包大小，导致接收方在一次读取中接收到了多个数据包的数据，造成数据粘在一起的情况。  <br/>

这些问题通常是由于TCP协议的特性导致的，如TCP是基于字节流传输的、无消息边界等。解决这些问题的方法包括使用消息边界标记、消息长度前缀、定长消息等方式进行数据分割和组织，以及在应用层进行数据的解析和处理。   <br/>

<br/>

**为什么TCP需要3次握手而不是2次？**   <br/>
当双方通信时发送数据包，可能会造成 乱序+数据丢失 的问题    <br/>

在这种情况下，想要获取正确完整的数据，只要两种机制：编号以及确认。  <br/>

编号针对与乱序问题，确认机制针对的是丢失问题。           <br/>

编号：由于需要对每个数据包进行编号，因此a向b发送消息之前，必须把数据包的初始编号告诉b，又因为b也可以向a发送消息，因此双方在通信之前必须知道对方的初始编号，这样才能正确的进行数据包收到后的确认以及对数据包根据编号进行重排。   <br/>
于是ab双方协定，聊天发起方先把编号告诉聊天接收方，聊天接收方收到发起方编号后也把自己的编号告诉发起方。   <br/>

确认机制：b收到每一个数据包后会回复一个收到，并附带接收数据包的编号X+1，也就是期待a发出的下一个数据包的编号。    <br/>
这样a在接收到数据包编号是X+1后就确信b已经收到了数据包X，如果a在一定时间内没有收到数据包编号是X+1，那么就会重新再发送数据包X（重传机制）。   <br/>

<br/>

**服务端挂了，客户端的 TCP 连接还在吗？**  <br/>

1、服务端的进程在发生崩溃的时候，内核会发送 FIN 报文，与客户端进行四次挥手。  <br/>
TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，  <br/>
于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP四次挥手的过程。  <br/>

2、服务端主机宕机，则不会发生四次挥手，具体后续会发生什么，还要看客户端会不会发送数据：  <br/>
(1)如果客户端会发送数据，由于服务端已经不存在，客户端得不到响应，在等待一定时长后，客户端的数据报文会 超时重传。  <br/>
当重传次数达到一定阈值后，内核就会判定该 TCP 连接有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了，于是客户端的 TCP 连接就会断开。  <br/>
(2)如果客户端一直不会发送数据，再看客户端有没有开启 TCP keepalive 机制  <br/>
* 如果有开启，客户端一直不发送数据，在一段时间后，TCP 就会发送探测报文，探测服务端是否存活，检测到服务端的 TCP 连接已经不存在，则会断开自身的 TCP 连接；  <br/>
* 如果没有开启，客户端的 TCP 连接会一直存在，并且一直保持在 ESTABLISHED 状态，不会断开。  <br/>
注：由此可知，在没有使用 TCP 保活机制，且双方不传输数据的情况下，一方的 TCP 连接处在 ESTABLISHED 状态时，并不代表另一方的 TCP 连接还一定是正常的。  <br/>

TCP keepalive 机制：  <br/>
(1)如果对端是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 TCP 保活时间会被重置，等待下一个 TCP 保活时间的到来。  <br/>
(2)如果对端主机崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后 没有响应，连续几次直到达到 保活探测次数 后，TCP 会报告该 TCP 连接已经死亡。  <br/>
原理：定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文。  <br/>
该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序【TCP keepalive 是 TCP 层（内核态）实现的】。  <br/>

在 Linux 内核可以有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔，以下都为默认值：  <br/>
net.ipv4.tcp_keepalive_time=7200  //表示保活时间是 7200 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制  <br/>
net.ipv4.tcp_keepalive_intvl=75   //表示每次检测间隔 75 秒  <br/>
net.ipv4.tcp_keepalive_probes=9   //表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。  <br/>
也就是说在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接。  <br/>
注意，应用程序如果想使用 TCP 保活机制，需要通过 socket 接口设置 SO_KEEPALIVE选项 才能够生效，如果没有设置，那么就无法使用 TCP 保活机制  <br/>

<br/>
