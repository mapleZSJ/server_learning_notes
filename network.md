## TCP

**一台机器理论上能创建多少条TCP连接：**    <br/>
如果在不考虑服务器的内存和文件句柄资源的情况下，理论上一个服务端进程最多能支持约为 2 的 48 次方（2^32 (ip数) * 2^16 (端口数），约等于两百多万亿。    <br/>

但是在实际中是支持不了这个数值的，每个 TCP 连接都是一个文件，会占用文件句柄资源，也会占用一定的内存空间。    <br/>

一台服务器是可以有多个服务端进程的，每个服务端进程监听不同的端口，当然所有65535个端口你都可以用来监听一遍，这样理论上线就到了2的32次方（ip数）×2的16次方（port数）×2的16次方（服务器port数）个，
基本相当于无穷个了。    <br/>

但Linux每维护一条TCP连接都要花费内存资源的，每一条静止状态（不发送数据和不接收数据）的 TCP 连接大约需要 3.44K 的内存，那么 8 GB 物理内存的服务器，
最大能支持的 TCP 连接数=8GB/3.44KB=2,438,956（约240万）。    <br/>

实际过程中的 TCP 连接，还会进行发送数据和接收数据了，那么这些过程还是会额外消耗更多的内存资源的，并发很难达到百万级别。    <br/>

<br/>

**TCP 如何保证传输的可靠性：**    <br/>
1 数据包传输：应用数据被切割成最适合发送的数据包，再传输给网络段，这块涉及半包和粘包，切割和合并 Nagle 算法等问题，还涉及到数据链路层的 MTU 和网络传输层的 MSS 的限制。    <br/>

2 序列号：序列号用于对数据包进行排序和重组，以保证数据的顺序性；利用序列号保证数据包有序，并且按序列号进行排序和数据包去重。    <br/>

3 校验和：TCP 校验和机制 CRC 循环冗余校验。数据在传输过程中如果发生变化，那么校验和就会产生差别，TCP 会丢弃这个报文段，会请求发送方重传数据，并且不会发 ACK 确认。    <br/>

4 确认和重传机制：TCP使用确认和重传机制来确保数据的可靠传输。发送方在发送数据后，会等待接收方发送确认（ACK）信号。如果发送方在合理的时间内未收到确认(如：数据包丢失、或者由于网络延迟没有收到 ACK)，就会认为数据丢失，触发重传机制，重新发送数据。    <br/>

5 流量控制：TCP使用滑动窗口机制进行流量控制，TCP 每一方都有固定大小的缓冲空间，这里面涉及到一个反向压力的概念，根据接收方的处理速率，能够给发送方进行反馈，发送方能够去调整发送的速率，防止包丢失。    <br/>

6 拥塞控制：TCP通过拥塞控制算法来避免网络拥塞，并在发生拥塞时降低数据的发送速率。TCP 发送数据由两个变量控制，接受方接受速率，网络拥塞（延迟）程度，发送方发送的数据的大小是滑动窗口和拥塞窗口的最小值。拥塞控制算法包括慢启动、拥塞避免、快速重传和快速恢复等。   <br/>

<br/>

**TCP半包和粘包问题：**    <br/>
它们是在数据传输过程中可能出现的两种常见问题：  <br/>

半包问题：当发送方将数据拆分成较小的数据包发送，而接收方一次性读取的数据量小于发送方发送的数据包大小时，就会导致接收方接收到的数据不完整，即出现了半包问题。  <br/>

粘包问题：与半包问题相反，粘包问题是指接收方一次性读取的数据量大于发送方发送的数据包大小，导致接收方在一次读取中接收到了多个数据包的数据，造成数据粘在一起的情况。  <br/>

这些问题通常是由于TCP协议的特性导致的，如TCP是基于字节流传输的、无消息边界等。解决这些问题的方法包括使用消息边界标记、消息长度前缀、定长消息等方式进行数据分割和组织，以及在应用层进行数据的解析和处理。   <br/>



**为什么TCP需要3次握手而不是2次？**   <br/>
当双方通信时发送数据包，可能会造成 乱序+数据丢失 的问题    <br/>

在这种情况下，想要获取正确完整的数据，只要两种机制：编号以及确认。  <br/>

编号针对与乱序问题，确认机制针对的是丢失问题。           <br/>

编号：由于需要对每个数据包进行编号，因此a向b发送消息之前，必须把数据包的初始编号告诉b，又因为b也可以向a发送消息，因此双方在通信之前必须知道对方的初始编号，这样才能正确的进行数据包收到后的确认以及对数据包根据编号进行重排。   <br/>
于是ab双方协定，聊天发起方先把编号告诉聊天接收方，聊天接收方收到发起方编号后也把自己的编号告诉发起方。   <br/>

确认机制：b收到每一个数据包后会回复一个收到，并附带接收数据包的编号X+1，也就是期待a发出的下一个数据包的编号。    <br/>
这样a在接收到数据包编号是X+1后就确信b已经收到了数据包X，如果a在一定时间内没有收到数据包编号是X+1，那么就会重新再发送数据包X（重传机制）。   <br/>

<br/>
